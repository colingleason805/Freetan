function process_gamestate(state){

}

function CreateGame(gameType:GameType, assignmentMethod:AssignmentMethod):GameObject{
    let hexes = CreateBoard(gameType, assignmentMethod)

    return new GameObject(4, gameType, hexes)
}

function CreateBoard(gameType:GameType, assignmentMethod:AssignmentMethod):Hex[]{
    let hexes:Hex[] = new Array()

    if (gameType == GameType.Base){

        let matTypePool = CreateMaterialTypePool(gameType)

        // Default boardsize for Base is 19
        // 19 tiles will be generated by going a distance of 2 from (0,0,0) in all directions
        hexes = GenerateHexes(19, -2, 2, -2, 2, -2, 2, matTypePool)
        
        AssignNumbersToHexes(hexes, CreateNumbersPool(19), assignmentMethod)

    }

    return hexes
}

function GenerateHexes(boardSize:number, qLowBound:number, qHighBound:number, rLowBound:number, rHighBound:number, 
    sLowBound:number, sHighBound:number, matTypePool:MaterialType[]){
        let hexes:Hex[] = new Array()

        let q:number = qLowBound
        let r:number = rLowBound
        let s:number = sLowBound

        for(let i=0; i<boardSize;i++){

            let matType:MaterialType = GetRandomMatTypeFromPoolAndSplice(matTypePool)

            hexes.push(new Hex(i,[q,r,s], matType))

            // we increment the coordinates counters up to their highest boundary one at a time
            if (q < qHighBound)
            {
                q++
            }
            else if (r < rHighBound){
                r++
            }
            else if(s < sHighBound){
                s++
            }
        }
        return hexes
}

/*
    Assign a number to each Hex
*/
function AssignNumbersToHexes(hexes:Hex[], numbers:number[], assignmentMethod:AssignmentMethod){
    
    if(assignmentMethod == AssignmentMethod.Random){
        hexes.forEach(hex => {

            if(hex.material == MaterialType.Desert || hex.material == MaterialType.Ocean){
                return
            }

            let index = Math.floor(Math.random() * numbers.length); 
            hex.diceValue = numbers[index]
            numbers.splice(index,1)

        });
    }
}

function CreateMaterialTypePool(gameType:GameType):MaterialType[]{
    if (gameType == GameType.Base){
        let matTypes:MaterialType[] = new Array()
        matTypes.push(MaterialType.Sheep, MaterialType.Sheep,MaterialType.Sheep,MaterialType.Sheep)
        matTypes.push(MaterialType.Wheat, MaterialType.Wheat,MaterialType.Wheat,MaterialType.Wheat)
        matTypes.push(MaterialType.Lumber, MaterialType.Lumber,MaterialType.Lumber,MaterialType.Lumber)
        matTypes.push(MaterialType.Ore, MaterialType.Ore,MaterialType.Ore)
        matTypes.push(MaterialType.Brick, MaterialType.Brick,MaterialType.Brick)
        matTypes.push(MaterialType.Desert)
    }
    return []
}

function CreateNumbersPool(boardSize:number):number[]{
    if(boardSize == 19){
        return [2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12]
    }

    return []
}

/*
    Selects a random material type from the given pool, removes it from the pool, and returns the removed item
*/
function GetRandomMatTypeFromPoolAndSplice(matTypePool:MaterialType[]):MaterialType{
    // Gets a random integer from 0 to matTypePool.length:
    let index = Math.floor(Math.random() * matTypePool.length); 

    let matType = matTypePool[index]

    matTypePool.splice(index, 1)

    return matType
}

// function IsValidStructurePlacement(hexId:number, vertex:number, playerId:number, game:GameObject){

// }

// function IsValidRoadPlacement(){

// }

class GameObject {

    constructor(numPlayers:number, gameType:GameType, hexes:Hex[]){
        this.players =  Array.from(Array(numPlayers), (_, index) => index + 1);
        this.gameType = gameType
        this.hexes = hexes
    }

    hexes: Hex[]
    players:number[]
    gameType:GameType

}

// The catan board is always considered to have a fixed orientation
//
//           -r  
//          1--2
//     +s  /    \  +q
//        6      3
//     -q  \    /  -s
//          5--4
//           +r
//
class Hex{

    constructor(id:number, coordinates:[number,number,number], material:MaterialType){
        this.id = id
        this.coordinates = coordinates
        this.material = material
    }

    // pk assigned at creation by game engine
    id: number
    
    // coordinates are cube coordinates with q, r,  s axis
    // see https://www.redblobgames.com/grids/hexagons/ 
    coordinates:[number, number, number]

    material: MaterialType
    diceValue: number

    // map of a hex's vertices to structures on those vertices
    //
    // key is a hex's vertice
    // value is a sub-map of the given player's ID to the structure
    //
    structures: Map<number, Map<number, Structure>>

    // array of the edges on the Hex that have roads on them
    roads: [number, number][]

    // boolean value for indicating presence of the Robber
    blocked: boolean
}

enum MaterialType{
    Sheep,
    Lumber,
    Brick,
    Wheat,
    Ore,
    Desert,
    Ocean
}

enum Structure{
    Settlement,
    City,
    Walls,
    Knight
}

enum GameType{
    Base,
    Expansion,
    CitiesAndKnights,
    CitiesAndKnightsExpansion,
    SeaFarers,
    SeaFarersExpansion
}

enum AssignmentMethod{
    Random,
    Balanced
}